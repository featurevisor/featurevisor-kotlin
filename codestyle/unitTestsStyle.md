# Unit tests

### Naming convention

```kotlin
val systemUnderTest = ClassToTest()
```

### Assertions

Always use AssertJ framework for assertions, always import it on class level.

```kotlin
import org.assertj.core.api.Assertions.assertThat
```

```kotlin
// ðŸ”´ don't
Assertions.assertThat(value).isEqualTo("expected")

// ðŸŸ¢ do
assertThat(value).isEqualTo("expected")
```

### Instance mocking

```kotlin
private val mockDependency: Dependecy = mock {
    on { shouldShowSomethingElse() } doReturn false
}

private val mockView: View = mock()
private val spyInstance = spy(ObjectInstance())

//optional newline for better readability
private val mockSecondDependency: SecondDependecy = mock()
```

**Note:** Don't use `mock<Class>()`, define type explicitly for variable

### Before/After

```kotlin
@Before
fun setUp() {
    systemUnderTest.attachView(mockView)
}
```

**Note:** Use `@Before` when needed

**Note:** Keep method name autogenerated (Android Studio creates `setUp()` method), because we are lazy

### Test methods naming

Contain test method in backticks for improved readability.

```kotlin
@Test
fun `show dialog on error`() {
    systemUnderTest.showError()

    verify(mockView).showError()
}

```

**Note:** Use plural form instead of singular (in this case use `show` instead of `shows`)

### Visual given/when/then separation

```kotlin
@Test
fun `show dialog on error`() {
    systemUnderTest.attachView(mockView)

    systemUnderTest.showError()

    verify(mockView).showError()
}
```

### Preferred verification methods

From most preferred to least preferred

```kotlin
@Test
fun `show dialog on error`() {
    val expectedValue = "text here"

    systemUnderTest.showError()
    
    verify(mockView).showErrorText(expectedValue)
    verify(mockView).showErrorText(eq(expectedValue), any())
    verify(mockView).showErrorText(eq(expectedValue), argThat(it.hasSomeValue))
    argumentCaptor<SomeObject>().apply {
        verify(mockView).showErrorText(eq(expectedValue), capture())
        firstValue.invoke()

        //some assertion depending on the firstValue.invoke() call
    }
}
```

### Verify other possible interactions

```kotlin
@Test
fun `don't show error`() {
    whenever(mockDependency.shouldShowError()).thenReturn(false)

    systemUnderTest.showError()

    verifyNoInteractions() //if makes sense, but be cautious
    verify(mockView, never()).showError()
    verifyNoMoreInteractions() //if makes sense
}
```

### Verify repeated interactions

```kotlin
@Test
fun `show error two times`() {
    systemUnderTest.showError()
    systemUnderTest.showError()

    verify(mockView, times(2)).showError()
}
```

### Nice asserts for rx observables

```kotlin
@Test
fun `token is set multiple times`() {
    val observable = systemUnderTest.getLoginData().test()

    observable
        .assertValue { it.token == expectedData.token }
        .assertValueAt(2) { it.token == "token1" }
        .assertValueAt(3) { it.token == "token2" }
        .assertValueAt(4) { it.token == "token3" }
}
```

### Locale sensitive unit tests

It's not guaranteed that on developer machines the same locale is set. Because of that we need to enforce specific locale to be sure that expected string values are matching.

```kotlin
@get:Rule
val defaultLocaleRule = SetLocaleRule(Locale.ENGLISH)
```

### Mocking Android SDK classes

If subject of the unit test requires or uses inside some native Android SDK classes, annotate test with following annotation:

```kotlin
@RunWith(AndroidJUnit4::class)
@Config(manifest = Config.NONE, application = TestApplication::class)
class SomeClassTest {
```

### Use parameterized test when it makes sense

```kotlin
@RunWith(Parameterized::class)
class ConvertBytesToMegaBytesTest(
    private val bytes: Long,
    private val expectedMegabytes: Int,
) {

    val systemUnderTest = Object()

    companion object {
        @JvmStatic
        @Parameterized.Parameters
        fun data(): List<Array<*>> =
            listOf(
                arrayOf(1024000, 1),
                arrayOf(2048000, 2),
                arrayOf(4096000, 4),
                arrayOf(8192000, 8)
            )
    }

    @Test
    fun `check if conversion works as expected`() {
        val outputFormat = systemUnderTest.convertBytesToMegaBytes(bytes)

        assertThat(outputFormat).isEqualTo(expectedMegabytes)
    }
}
```

**Note:** Consider wrapping test variables into something more readable, especially when there is a lot of them

```kotlin
@RunWith(Parameterized::class)
class FollowParameterizedServiceTest(
    private val parameters: Parameters,
) {

    companion object {
        @JvmStatic
        @Parameterized.Parameters(name = "{0}")
        fun data(): Collection<Array<Parameters>> = listOf(
            Parameters(signedUpDaysAgo = NOW.minusDays(0L), daysDelayVariable = 0L, hasSeenOnboardingBefore = true, isOnboardingVisible = false).build(),
            Parameters(signedUpDaysAgo = NOW.minusDays(1L), daysDelayVariable = 0L, hasSeenOnboardingBefore = true, isOnboardingVisible = false).build(),
            //a lot more
        )
    }

    val systemUnderTest = Object()

    @Test
    fun `verify`() {
        //assert
    }

    data class Parameters(
        val signedUpDaysAgo: LocalDateTime?,
        val daysDelayVariable: Long,
        val hasSeenOnboardingBefore: Boolean,
        val isOnboardingVisible: Boolean,
    ) {
        fun build() = arrayOf(this)
    }
}
```
