/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.featurevisor.sdk

import com.featurevisor.sdk.FeaturevisorError.FetchingDataFileFailed
import com.featurevisor.sdk.FeaturevisorError.MissingDatafileOptions
import com.featurevisor.types.BucketKey
import com.featurevisor.types.BucketValue
import com.featurevisor.types.Context
import com.featurevisor.types.DatafileContent
import com.featurevisor.types.EventName
import com.featurevisor.types.EventName.ACTIVATION
import com.featurevisor.types.EventName.READY
import com.featurevisor.types.EventName.REFRESH
import com.featurevisor.types.EventName.UPDATE
import com.featurevisor.types.Feature
import com.featurevisor.types.StickyFeatures
import kotlinx.coroutines.Job
import kotlinx.serialization.json.Json

typealias ConfigureBucketKey = (Feature, Context, BucketKey) -> BucketKey
typealias ConfigureBucketValue = (Feature, Context, BucketValue) -> BucketValue
typealias InterceptContext = (Context) -> Context
typealias DatafileFetchHandler = (datafileUrl: String) -> Result<DatafileContent>

val emptyDatafile = DatafileContent(
    schemaVersion = "1",
    revision = "unknown",
    attributes = emptyList(),
    segments = emptyList(),
    features = emptyList()
)

class FeaturevisorInstance private constructor(options: InstanceOptions) {

    companion object {
        fun createInstance(options: InstanceOptions): FeaturevisorInstance {
            return FeaturevisorInstance(options)
        }
    }

    //    private val on: (EventName, Listener) -> Unit
    //    private val off: (EventName) -> Unit
    private val addListener: (EventName, Listener) -> Unit
    private val removeListener: (EventName) -> Unit
    private val removeAllListeners: () -> Unit

    internal val statuses = Statuses(ready = false, refreshInProgress = false)
    internal val logger = options.logger
    internal val initialFeatures = options.initialFeatures
    internal val interceptContext = options.interceptContext
    internal val emitter: Emitter = Emitter()
    internal val datafileUrl = options.datafileUrl
    internal val handleDatafileFetch = options.handleDatafileFetch
    internal val refreshInterval = options.refreshInterval
    internal lateinit var datafileReader: DatafileReader
    internal var stickyFeatures = options.stickyFeatures
    internal var bucketKeySeparator = options.bucketKeySeparator
    internal var configureBucketKey = options.configureBucketKey
    internal var configureBucketValue = options.configureBucketValue
    internal var refreshJob: Job? = null

    init {
        with(options) {
            if (onReady != null) {
                emitter.addListener(READY, onReady)
            }
            if (onRefresh != null) {
                emitter.addListener(REFRESH, onRefresh)
            }
            if (onUpdate != null) {
                emitter.addListener(UPDATE, onUpdate)
            }
            if (onActivation != null) {
                emitter.addListener(ACTIVATION, onActivation)
            }

            // TODO: Needed?
//        on = emitter::addListener
//        off = emitter::removeListener
            addListener = emitter::addListener
            removeListener = emitter::removeListener
            removeAllListeners = emitter::removeAllListeners

            when {
                datafile != null -> {
                    datafileReader = DatafileReader(datafileJson = datafile)
                    statuses.ready = true
                    emitter.emit(READY)
                }

                datafileUrl != null -> {
                    fetchDatafileContent(datafileUrl) { result: Result<DatafileContent> ->
                        if (result.isSuccess) {
                            datafileReader = DatafileReader(datafileJson = result.getOrThrow())
                            statuses.ready = true
                            emitter.emit(READY)
                            if (refreshInterval != null) {
                                startRefreshing()
                            }
                        } else {
                            logger?.error("Failed to fetch datafile: $result")
                            throw FetchingDataFileFailed(result.toString())
                        }
                    }
                }

                else -> throw MissingDatafileOptions
            }
        }

    }

    fun setDatafile(datafileJSON: String) {
        val data = datafileJSON.toByteArray(Charsets.UTF_8)
        try {
            val datafileContent = Json.decodeFromString<DatafileContent>(String(data))
            datafileReader = DatafileReader(datafileJson = datafileContent)
        } catch (e: Exception) {
            logger?.error("could not parse datafile", mapOf("error" to e))
        }
    }

    fun setDatafile(datafileContent: DatafileContent) {
        datafileReader = DatafileReader(datafileJson = datafileContent)
    }

    fun setStickyFeatures(stickyFeatures: StickyFeatures?) {
        this.stickyFeatures = stickyFeatures
    }

    fun getRevision(): String {
        return datafileReader.getRevision()
    }
}
