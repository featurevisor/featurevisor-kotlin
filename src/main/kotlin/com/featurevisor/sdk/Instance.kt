/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.featurevisor.sdk

import com.featurevisor.sdk.FeaturevisorError.*
import com.featurevisor.types.BucketKey
import com.featurevisor.types.BucketValue
import com.featurevisor.types.Context
import com.featurevisor.types.DatafileContent
import com.featurevisor.types.EventName
import com.featurevisor.types.EventName.*
import com.featurevisor.types.Feature
import com.featurevisor.types.FeatureKey
import com.featurevisor.types.OverrideFeature
import com.featurevisor.types.RuleKey
import com.featurevisor.types.StickyFeatures
import com.featurevisor.types.Traffic
import com.featurevisor.types.VariableKey
import com.featurevisor.types.VariableSchema
import com.featurevisor.types.VariableValue
import com.featurevisor.types.Variation
import com.featurevisor.types.VariationValue
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.decodeFromJsonElement
import kotlinx.serialization.json.encodeToJsonElement
import java.util.Timer

typealias ConfigureBucketKey = (Feature, Context, BucketKey) -> BucketKey
typealias ConfigureBucketValue = (Feature, Context, BucketValue) -> BucketValue
typealias InterceptContext = (Context) -> Context
typealias DatafileFetchHandler = (datafileUrl: String) -> Result<DatafileContent>

data class Statuses(var ready: Boolean, var refreshInProgress: Boolean)

enum class EvaluationReason(val value: String) {
    NOT_FOUND("not_found"),
    NO_VARIATIONS("no_variations"),
    DISABLED("disabled"),
    REQUIRED("required"),
    OUT_OF_RANGE("out_of_range"),
    FORCED("forced"),
    INITIAL("initial"),
    STICKY("sticky"),
    RULE("rule"),
    ALLOCATED("allocated"),
    DEFAULTED("defaulted"),
    OVERRIDE("override"),
    ERROR("error")
}

@Serializable
data class Evaluation(
    val featureKey: FeatureKey,
    val reason: EvaluationReason,
    val bucketValue: BucketValue? = null,
    val ruleKey: RuleKey? = null,
    val enabled: Boolean? = null,
    val traffic: Traffic? = null,
    val sticky: OverrideFeature? = null,
    val initial: OverrideFeature? = null,
    val variation: Variation? = null,
    val variationValue: VariationValue? = null,
    val variableKey: VariableKey? = null,
    val variableValue: VariableValue? = null,
    val variableSchema: VariableSchema? = null,
) {
    fun toDictionary(): Map<String, Any> {
        val data = try {
            val json = Json.encodeToJsonElement(this)
            Json.decodeFromJsonElement<Map<String, Any>>(json)
        } catch (e: Exception) {
            emptyMap()
        }
        return data
    }
}

val emptyDatafile = DatafileContent(
    schemaVersion = "1",
    revision = "unknown",
    attributes = emptyList(),
    segments = emptyList(),
    features = emptyList()
)

class FeaturevisorInstance private constructor(options: InstanceOptions) {

    companion object {
        fun createInstance(options: InstanceOptions): FeaturevisorInstance {
            return FeaturevisorInstance(options)
        }
    }

    private val emitter: Emitter = Emitter()
    //    private val on: (EventName, Listener) -> Unit
    private val addListener: (EventName, Listener) -> Unit
    //    private val off: (EventName) -> Unit
    private val removeListener: (EventName) -> Unit
    private val removeAllListeners: () -> Unit
    private var timer: Timer? = null

    internal val statuses = Statuses(ready = false, refreshInProgress = false)
    internal val logger = options.logger
    internal val initialFeatures = options.initialFeatures
    internal var stickyFeatures = options.stickyFeatures
    internal var datafileReader: DatafileReader? = null
//    var urlSession: URLSession = URLSession(configuration = options.sessionConfiguration)

    init {
        with(options) {
            if (onReady != null) {
                emitter.addListener(READY, onReady)
            }
            if (onRefresh != null) {
                emitter.addListener(REFRESH, onRefresh)
            }
            if (onUpdate != null) {
                emitter.addListener(UPDATE, onUpdate)
            }
            if (onActivation != null) {
                emitter.addListener(ACTIVATION, onActivation)
            }

            // TODO: Needed?
//        on = emitter::addListener
//        off = emitter::removeListener
            addListener = emitter::addListener
            removeListener = emitter::removeListener
            removeAllListeners = emitter::removeAllListeners

            when {
                datafile != null -> {
                    datafileReader = DatafileReader(datafileJson = datafile)
                    statuses.ready = true
                    emitter.emit(READY)
                }

                datafileUrl != null -> {
                    fetchDatafileContent(datafileUrl) { result: Result<DatafileContent> ->
                        if (result.isSuccess) {
                            datafileReader = DatafileReader(datafileJson = result.getOrThrow())
                            statuses.ready = true
                            emitter.emit(READY)
                            if (refreshInterval != null) {
                                startRefreshing()
                            }
                        } else {
                            logger?.error("Failed to fetch datafile: $result")
                            throw FetchingDataFileFailed(result.toString())
                        }
                    }
                }

                else -> throw MissingDatafileOptions
            }
        }

    }

    fun setDatafile(datafileJSON: String) {
        val data = datafileJSON.toByteArray(Charsets.UTF_8)
        try {
            val datafileContent = Json.decodeFromString<DatafileContent>(String(data))
            datafileReader = DatafileReader(datafileJson = datafileContent)
        } catch (e: Exception) {
            logger?.error("could not parse datafile", mapOf("error" to e))
        }
    }

    fun setDatafile(datafileContent: DatafileContent) {
        datafileReader = DatafileReader(datafileJson = datafileContent)
    }

    fun setStickyFeatures(stickyFeatures: StickyFeatures?) {
        this.stickyFeatures = stickyFeatures
    }

    fun getRevision(): String {
        return datafileReader!!.getRevision()
    }
}

//TODO: All of the below move to another place
private fun fetchDatafileContent(dataFileUrl: String?, lambda: (Result<DatafileContent>) -> Unit) {

}

private fun startRefreshing() {}
